% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/refitME_package.R
\name{refitME}
\alias{refitME}
\title{A wrapper function for correcting measurement error in predictor variables via the MCEM algorithm}
\source{
See \url{https://github.com/JakubStats/refitME} for an RMarkdown tutorial with examples.
}
\usage{
refitME(mod, sigma.sq.u, B = 50, epsilon = 1e-05, silent = FALSE, ...)
}
\arguments{
\item{mod}{: a \code{lm/glm/gam} object (S3 classes) or a \code{vlgm/vgam} object (S4 class) when using the \code{posbinomial} family. This is the naive fitted model. Make sure the first \eqn{p} input predictor variables entered in the naive model are the specified error-contaminated variables. These \eqn{p} predictors also need the measurement error variance to be specified in \code{sigma.sq.u}, see below.}

\item{sigma.sq.u}{: measurement error (ME) variance. A scalar if there is only one error-contaminated predictor variable, otherwise this must be stored as a covariance matrix.}

\item{B}{: the number of Monte Carlo replication values (default is set 50).}

\item{epsilon}{: convergence threshold (default is set to 0.00001).}

\item{silent}{: if \code{TRUE}, the convergence message (which tells the user if the model has converged and reports the number of iterations required) is suppressed (default is set to \code{FALSE}).}

\item{...}{: further arguments passed through to \code{lm}, \code{glm} or \code{gam}.}
}
\value{
\code{refitME} returns the naive fitted model object where coefficient estimates, the covariance matrix, fitted values, the log-likelihood, and residuals have been replaced with the final MCEM model fit. Standard errors and the effective sample size (which diagnose how closely the proposal distribution matches the posterior, see equation (2) of Stoklosa, Hwang and Warton) have also been included as outputs.
}
\description{
Function that extracts the fitted (naive) model object and wraps the MCEM algorithm to correct for measurement error/error-in-variables (currently available for \code{lm()}, \code{glm()} and \code{gam()}, excludes \code{lme()}, \code{nlme()} and \code{polr()} models).
}
\examples{
# A GLM example I - binary response data.

library(refitME)

data(Framinghamdata)

glm_naiv <- glm(Y ~ w1 + z1 + z2 + z3, x = TRUE, family = binomial, data = Framinghamdata)

# The error-contaminated predictor variable in this example is systolic blood pressure (w1).

sigma.sq.u <- 0.01259/2 # ME variance, as obtained from Carroll et al. (2006) monograph.

B <- 100  # The number of Monte Carlo replication values/SIMEX simulations.

glm_MCEM <- refitME(glm_naiv, sigma.sq.u, B)



# A GLM example II - presence-only data using a point-process model.

library(caret)

data(Corymbiaeximiadata)
dat <- Corymbiaeximiadata

Y1 <- dat$Y.obs

Rain <- dat$Rain
D.Main <- dat$D.Main
MNT <- dat$MNT  # The error-contaminated predictor (max temperature).

# PPM - using a Poisson GLM.

p.wt <- rep(1.e-6, length(Y1))
p.wt[Y1 == 0] <- 1

Y <- Y1/p.wt

X <- cbind(MNT, Rain, sqrt(D.Main))

colnames(X) <- c("w1", "z1", "z2")

dat1 <- data.frame(cbind(Y, p.wt, X))
colnames(dat1)[1:2] <- c("Y", "p.wt")

PPM_naiv <- glm(Y ~ poly(w1, degree = 2, raw = TRUE) +
                    poly(z1, degree = 2, raw = TRUE) +
                    poly(z2, degree = 2, raw = TRUE),
                    family = "poisson", weights = p.wt, data = dat1)

# PPM - using MCEM model.

sigma.sq.u <- 0.25  # Measurement error variance.

PPM_MCEM <- refitME(PPM_naiv, sigma.sq.u)

coord.dat <- cbind(dat$X, dat$Y)

colnames(coord.dat) <- c("Longitude", "Latitude")

pred.dats <- as.data.frame(cbind(coord.dat[, 1], coord.dat[, 2],
  PPM_MCEM$fitted.values))

colnames(pred.dats) <- c("x", "y", "preds")

levelplot(preds ~ x + y, data = pred.dats, asp = "iso", ylab = "Latitude",
  xlab = "Longitude", col.regions = heat.colors(1024)[900:1], cuts = 900,
  main = list("", cex = 5), scales = list(y = list(draw = FALSE),
  x = list(draw = FALSE), relation = "free"),
  colorkey = list(labels = list(cex = 0.8)))



# A GAM example using the air pollution data set from the SemiPar package.

library(refitME)
library(SemiPar)
library(mgcv)

data(milan.mort)

dat.air <- milan.mort

Y <- dat.air[, 6]  # Mortality counts.

n <- length(Y)

z1 <- (dat.air[, 1])
z2 <- (dat.air[, 4])
z3 <- (dat.air[, 5])
w1 <- log(dat.air[, 9])  # The error-contaminated predictor (total suspended particles).

dat <- data.frame(cbind(Y, w1, z1, z2, z3))

gam_naiv <- gam(Y ~ s(w1) + s(z1, k = 25) + s(z2) + s(z3),
   family = "poisson", data = dat)

sigma.sq.u <- 0.0915 # Measurement error variance.

B <- 5  # Consider increasing this if you want a more accurate answer.

gam_MCEM <- refitME(gam_naiv, sigma.sq.u, B)
plot(gam_MCEM)



# A VGAM example using the Prinia flaviventris capture-recapture data.

library(refitME)
library(VGAM)

data(Priniadata)

tau <- 17   # No. of capture occasions.
w1 <- Priniadata$w1

CR_naiv1 <- vglm(cbind(cap, noncap) ~ w1,
   VGAM::posbinomial(omit.constant = TRUE, parallel = TRUE ~ w1),
   data = Priniadata, trace = FALSE)

CR_naiv2 <- vgam(cbind(cap, noncap) ~ VGAM::s(w1, df = 2),
   VGAM::posbinomial(omit.constant = TRUE, parallel = TRUE ~ VGAM::s(w1, df = 2)),
   data = Priniadata, trace = FALSE)

sigma.sq.u <- 0.37/var(w1) # Measurement error variance.

B <- 100

CR_MCEM <- refitME(CR_naiv2, sigma.sq.u, B)
}
\references{
Carroll, R. J., Ruppert, D., Stefanski, L. A., and Crainiceanu, C. M. (2006). \emph{Measurement Error in Nonlinear Models: A Modern Perspective.} 2nd Ed. London: Chapman & Hall/CRC.

Stoklosa, J., Hwang, W-H., and Warton, D.I. \pkg{refitME}: Measurement Error Modelling using Monte Carlo Expectation Maximization in \proglang{R}.
}
\seealso{
\code{\link{MCEMfit_glm}} and \code{\link{MCEMfit_gam}}
}
\author{
Jakub Stoklosa, Wen-Han Hwang and David I. Warton.
}
